package com.kmwllc.lucille.core;

import com.kmwllc.lucille.message.WorkerMessageManager;
import com.typesafe.config.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;

/**
 * TODO: reconcile with com.kmwllc.lucille.core.PipelineWorker
 */
class Worker implements Runnable {

  private static final Logger log = LoggerFactory.getLogger(Worker.class);
  
  private final WorkerMessageManager manager;

  private final Pipeline pipeline;

  private volatile boolean running = true;

  public void terminate() {
    log.info("terminate called");
    running = false;
  }

  public Worker(Config config, WorkerMessageManager manager) throws Exception {
    this.manager = manager;
    this.pipeline = Pipeline.fromConfig(config);
  }

  @Override
  public void run() {
    while (running) {
      Document doc;
      try {
        doc = manager.pollDocToProcess();
      } catch (Exception e) {
        log.info("interrupted " + e);
        terminate();
        return;
      }

      if (doc == null) {
        continue;
      }

      try {
        List<Document> results = pipeline.processDocument(doc);

        // send CREATE events for any children document generated by the pipeline;
        // Note: we want to make sure that the Runner is notified of any generated children
        // BEFORE the parent document is completed. This prevents a situation where the Runner
        // assumes the run is complete because the parent is complete and the Runner didn't know
        // about the children.
        for (Document result : results) {
          // a document is a child if it has a different ID from the initial document
          if (!doc.getId().equals(result.getId())) {
            manager.sendEvent(new Event(result.getId(),
              doc.getString("run_id"), null, Event.Type.CREATE, Event.Status.SUCCESS));
          }
        }

        // send the initial document and any children to the topic for processed documents
        for (Document result : results) {
          manager.sendCompleted(result);
        }

      } catch (Exception e) {

        // TODO: send an error event to the event topic

        log.error("Error processing document: " + doc.getId(), e);
      }
    }

    try {
      manager.close();
    } catch (Exception e) {
      log.error("Error closing message manager", e);
    }

    log.info("Exiting");
  }

  public static Worker startThread(Config config, WorkerMessageManager manager) throws Exception {
    Worker worker = new Worker(config, manager);
    Thread workerThread = new Thread(worker);
    workerThread.start();
    return worker;
  }
}
